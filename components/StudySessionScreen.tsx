import * as React from 'react';
import { StudySessionData, Question, SessionItemState, SessionWordResult, Table, VocabRow, StudyMode, Relation, RelationDesign, CardFaceDesign, TypographyDesign, AppSettings, Theme } from '../types';
import Icon from './Icon';
import { playSpeech, stopSpeech } from '../services/audioService';
import { regenerateQuestionForRow } from '../utils/studySessionGenerator';
import ConfirmationModal from './ConfirmationModal';
import { generateSpeech, generateExampleSentence, generateHint } from '../services/geminiService';
import { useAppContext } from '../context/AppContext';

function decode(base64: string) { const binaryString = atob(base64); const len = binaryString.length; const bytes = new Uint8Array(len); for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); } return bytes; }
async function decodeAudioData(data: Uint8Array, ctx: AudioContext, sampleRate: number, numChannels: number): Promise<AudioBuffer> { const dataInt16 = new Int16Array(data.buffer); const frameCount = dataInt16.length / numChannels; const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate); for (let channel = 0; channel < numChannels; channel++) { const channelData = buffer.getChannelData(channel); for (let i = 0; i < frameCount; i++) { channelData[i] = dataInt16[i * numChannels + channel] / 32768.0; } } return buffer; }

const McqQuestionUI: React.FC<{ question: Question; onAnswer: (answer: string) => void; answered: boolean; currentAnswer: string }> = ({ question, onAnswer, answered, currentAnswer }) => { return ( <div className="grid grid-cols-1 md:grid-cols-2 gap-3"> {(question.options || []).map((option, index) => { const isCorrect = option === question.correctAnswer; let buttonClass = "bg-slate-200/70 dark:bg-slate-700 hover:bg-slate-200 dark:hover:bg-slate-600 text-slate-700 dark:text-white"; if (answered) { if (isCorrect) buttonClass = "bg-emerald-500/80 text-white"; else if (currentAnswer === option && !isCorrect) buttonClass = "bg-red-500/80 text-white"; else buttonClass = "bg-slate-200/50 dark:bg-slate-700 opacity-60 text-slate-600 dark:text-slate-300"; } return ( <button type="button" key={index} onClick={() => onAnswer(option)} disabled={answered} className={`p-3 rounded-lg text-left font-medium transition-all duration-200 ${buttonClass}`}> {option} </button> ); })} </div> ); };
const TfQuestionUI: React.FC<{ onAnswer: (answer: string) => void; answered: boolean; }> = ({ onAnswer, answered }) => ( <div className="grid grid-cols-2 gap-3"> <button onClick={() => onAnswer('True')} disabled={answered} className="p-4 rounded-lg font-bold text-lg bg-emerald-100 dark:bg-emerald-900/50 text-emerald-700 dark:text-emerald-300 hover:bg-emerald-200 dark:hover:bg-emerald-900 transition-colors disabled:opacity-50">True</button> <button onClick={() => onAnswer('False')} disabled={answered} className="p-4 rounded-lg font-bold text-lg bg-red-100 dark:bg-red-900/50 text-red-700 dark:text-red-300 hover:bg-red-200 dark:hover:bg-red-900 transition-colors disabled:opacity-50">False</button> </div> );
const TypingQuestionUI: React.FC<{ onAnswer: (answer: string) => void; answered: boolean }> = ({ onAnswer, answered }) => { const [typingAnswer, setTypingAnswer] = React.useState(''); const handleSubmit = (e: React.FormEvent) => { e.preventDefault(); onAnswer(typingAnswer); }; return ( <form onSubmit={handleSubmit}> <input type="text" value={typingAnswer} onChange={(e) => setTypingAnswer(e.target.value)} disabled={answered} placeholder="Type your answer..." autoFocus className="w-full bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-lg px-4 py-3 text-lg text-slate-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-emerald-500 transition mb-2" /> <button type="submit" disabled={answered || !typingAnswer.trim()} className="w-full bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-emerald-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"> Check Answer </button> </form> ); };
const FullExplanationPanel: React.FC<{ question: Question; onOpenGalleryView: (table: Table, rowId: string) => void; }> = ({ question, onOpenGalleryView }) => { const { tables } = useAppContext(); const table = tables.find(t => t.id === question.tableId); const row = table?.rows.find(r => r.id === question.rowId); if (!row || !table) return null; return ( <div className="mt-3 p-3 bg-slate-100 dark:bg-slate-700/50 rounded-lg"> <div className="flex justify-between items-center mb-2"> <h4 className="font-bold text-sm text-slate-700 dark:text-slate-200">Full Details</h4> <button onClick={() => onOpenGalleryView(table, row.id)} className="text-xs font-semibold text-emerald-600 dark:text-emerald-400 hover:underline flex items-center gap-1"> <Icon name="list-bullet" className="w-4 h-4"/> View in Gallery </button> </div> <div className="space-y-1"> {table.columns.map(col => ( <div key={col.id} className="grid grid-cols-3 gap-2 text-xs"> <span className="font-semibold text-slate-500 dark:text-slate-400 truncate">{col.name}</span> <span className="col-span-2 text-slate-800 dark:text-slate-300">{row.cols[col.id] || '-'}</span> </div> ))} </div> </div> ); };
const TopTracker: React.FC<{ wordStates: { [key: string]: SessionItemState }; questionOrder: string[]; sessionQueue: Question[]; showWords: boolean; }> = ({ wordStates, questionOrder, sessionQueue, showWords }) => { const questionsById = React.useMemo(() => sessionQueue.reduce((acc, q) => ({...acc, [q.rowId]: q}), {} as Record<string, Question>), [sessionQueue]); const getStateStyle = (state: SessionItemState) => { switch (state) { case SessionItemState.Unseen: return { bg: 'bg-slate-300 dark:bg-slate-600', text: 'text-slate-600 dark:text-slate-300' }; case SessionItemState.Fail: return { bg: 'bg-red-400 dark:bg-red-600', text: 'text-red-800 dark:text-red-200' }; case SessionItemState.Pass1: return { bg: 'bg-yellow-400 dark:bg-yellow-600', text: 'text-yellow-800 dark:text-yellow-200' }; case SessionItemState.Pass2: return { bg: 'bg-emerald-400 dark:bg-emerald-500', text: 'text-emerald-800 dark:text-emerald-100' }; } }; if (!showWords) return <div className="flex gap-1 h-2">{questionOrder.map(rowId => <div key={rowId} className={`flex-1 rounded-full transition-colors duration-300 ${getStateStyle(wordStates[rowId]).bg}`}></div>)}</div>; return <div className="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 gap-2 max-h-32 overflow-y-auto pr-2">{questionOrder.map(rowId => <div key={rowId} className={`p-1.5 rounded-md text-center ${getStateStyle(wordStates[rowId]).bg}`}><span className={`text-xs font-semibold truncate block ${getStateStyle(wordStates[rowId]).text}`}>{questionsById[rowId]?.questionText || '...'}</span></div>)}</div>; };

const DEFAULT_TYPOGRAPHY: TypographyDesign = { color: '#111827', fontSize: '24px', fontFamily: 'sans-serif', textAlign: 'center', fontWeight: 'bold' };
const DARK_MODE_DEFAULT_TYPOGRAPHY: TypographyDesign = { ...DEFAULT_TYPOGRAPHY, color: '#f1f5f9' };
const DEFAULT_RELATION_DESIGN: RelationDesign = { front: { backgroundType: 'solid', backgroundValue: '#FFFFFF', gradientAngle: 135, typography: {}, layout: 'vertical' }, back: { backgroundType: 'solid', backgroundValue: '#F9FAFB', gradientAngle: 135, typography: {}, layout: 'vertical' } };

const upgradeRelationDesign = (relation: Relation, theme: Theme): Relation => {
    const newRelation = JSON.parse(JSON.stringify(relation));
    const defaultTypo = theme === 'dark' ? DARK_MODE_DEFAULT_TYPOGRAPHY : DEFAULT_TYPOGRAPHY;
    if (!newRelation.design) newRelation.design = JSON.parse(JSON.stringify(DEFAULT_RELATION_DESIGN));
    for (const face of ['front', 'back'] as const) {
        const faceDesign = newRelation.design[face];
        if (!faceDesign.typography) faceDesign.typography = {};
        const columnIds = face === 'front' ? newRelation.questionColumnIds : newRelation.answerColumnIds;
        for (const colId of columnIds) { if (!faceDesign.typography[colId]) faceDesign.typography[colId] = { ...defaultTypo }; }
    }
    return newRelation;
};

const StudySessionScreen: React.FC<{ session: StudySessionData }> = ({ session }) => {
  const { tables, settings, theme, handleEndSession, handleSessionQuit, handleSaveToJournal, handleOpenGalleryView } = useAppContext();
  const [sessionQueue, setSessionQueue] = React.useState<Question[]>([]);
  const [wordStates, setWordStates] = React.useState<Record<string, SessionItemState>>({});
  const [wordResults, setWordResults] = React.useState<SessionWordResult[]>([]);
  const [currentAnswer, setCurrentAnswer] = React.useState('');
  const [feedback, setFeedback] = React.useState<'correct' | 'incorrect' | null>(null);
  const [shake, setShake] = React.useState(false);
  const [isJournaled, setIsJournaled] = React.useState(false);
  const [isFinished, setIsFinished] = React.useState(false);
  const [speedMode, setSpeedMode] = React.useState(false);
  const [showWordsInTracker, setShowWordsInTracker] = React.useState(false);
  const [isConfirmingQuit, setIsConfirmingQuit] = React.useState(false);
  const [audioState, setAudioState] = React.useState<'idle' | 'loading' | 'playing' | 'error'>('idle');
  const audioCtx = React.useRef<AudioContext | null>(null);
  const [cardAnimationClass, setCardAnimationClass] = React.useState('animate-card-flip-in-next');
  const [exampleSentence, setExampleSentence] = React.useState<string | null>(null);
  const [isSentenceLoading, setIsSentenceLoading] = React.useState(false);
  const [hint, setHint] = React.useState<string | null>(null);
  const [isHintLoading, setIsHintLoading] = React.useState(false);
  const [hintUsed, setHintUsed] = React.useState(false);

  const initialQuestionOrder = React.useMemo(() => session.questions.map(q => q.rowId), [session.questions]);
  const allRowsFromSources = React.useMemo(() => Array.from(new Map(session.settings.sources.flatMap(s => tables.find(t => t.id === s.tableId)?.rows || []).map(r => [r.id, r])).values()), [session.settings.sources, tables]);

  React.useEffect(() => { if (!audioCtx.current) { audioCtx.current = new (window.AudioContext || (window as any).webkitAudioContext)({ sampleRate: 24000 }); } setSessionQueue(session.questions); setWordStates(session.questions.reduce((acc, q) => ({ ...acc, [q.rowId]: SessionItemState.Unseen }), {})); }, [session]);
  
  const currentQuestion = !isFinished ? sessionQueue[0] : null;
  const answered = feedback !== null;
  const currentTable = React.useMemo(() => { if (!currentQuestion) return null; return tables.find(t => t.id === currentQuestion.tableId) || null; }, [currentQuestion, tables]);
  const currentRelation = React.useMemo(() => { if (!currentQuestion || !currentTable) return null; return currentTable.relations.find(r => r.id === currentQuestion.relationId) || null; }, [currentQuestion, currentTable]);
  const upgradedRelation = React.useMemo(() => { if (!currentRelation) return null; return upgradeRelationDesign(currentRelation, theme); }, [currentRelation, theme]);

  React.useEffect(() => () => stopSpeech(), [currentQuestion]);
  
  const advanceQueue = () => { let newQueue = [...sessionQueue]; const [answeredQuestion] = newQueue.splice(0, 1); const currentState = wordStates[answeredQuestion.rowId]; const isCorrect = wordResults[wordResults.length - 1]?.isCorrect; if (!isCorrect || currentState !== SessionItemState.Pass1) { const newQuestion = regenerateQuestionForRow(answeredQuestion, allRowsFromSources, tables, session.settings); const reinsertIndex = isCorrect ? newQueue.length : 2; newQueue.splice(reinsertIndex, 0, newQuestion); } setFeedback(null); setCurrentAnswer(''); setIsJournaled(false); setAudioState('idle'); setExampleSentence(null); setIsSentenceLoading(false); setHint(null); setHintUsed(false); setIsHintLoading(false); setSessionQueue(newQueue); if (newQueue.length === 0) setIsFinished(true); };
  const handleNextQuestion = () => { if (cardAnimationClass !== '') return; setCardAnimationClass('animate-card-flip-out-next'); };
  const handleAnimationEnd = () => { if (cardAnimationClass === 'animate-card-flip-out-next') { advanceQueue(); setCardAnimationClass('animate-card-flip-in-next'); } else { setCardAnimationClass(''); } };
  const handleAnswer = (answer: string) => { if (answered || !currentQuestion) return; setCurrentAnswer(answer); const isCorrect = answer.trim().toLowerCase() === currentQuestion.correctAnswer.toLowerCase(); setFeedback(isCorrect ? 'correct' : 'incorrect'); if (!isCorrect) { setShake(true); setTimeout(() => setShake(false), 300); if(settings.journalMode === 'automatic') { handleSaveToJournal("Quiz Item (Incorrect)", `*Q: ${currentQuestion.questionText}*\n*A: ${currentQuestion.correctAnswer}*`); } } setWordResults(prev => [...prev, { rowId: currentQuestion.rowId, isCorrect, timestamp: Date.now(), hintUsed }]); const currentState = wordStates[currentQuestion.rowId]; const nextState = isCorrect ? (currentState === SessionItemState.Pass1 ? SessionItemState.Pass2 : SessionItemState.Pass1) : SessionItemState.Fail; setWordStates(prev => ({ ...prev, [currentQuestion.rowId]: nextState })); if (speedMode) setTimeout(() => handleNextQuestion(), 800); };
  const handlePlayAudio = async () => { if (!currentQuestion || audioState === 'loading') return; const textToSpeak = currentQuestion.questionText; if (!textToSpeak) return; if (currentTable?.audioConfig?.sourceColumnId && currentRelation?.questionColumnIds.includes(currentTable.audioConfig.sourceColumnId)) { setAudioState('loading'); try { const audioB64 = await generateSpeech(textToSpeak); if (!audioB64 || !audioCtx.current) throw new Error("Audio generation failed"); const audioBytes = decode(audioB64); const audioBuffer = await decodeAudioData(audioBytes, audioCtx.current, 24000, 1); const source = audioCtx.current.createBufferSource(); source.buffer = audioBuffer; source.connect(audioCtx.current.destination); source.onended = () => setAudioState('idle'); source.start(); setAudioState('playing'); } catch (error) { console.error("Error playing Gemini audio:", error); setAudioState('error'); setTimeout(() => setAudioState('idle'), 2000); } } else { playSpeech(textToSpeak).catch(err => console.error("Browser TTS error:", err)); } };
  const handleGenerateExample = async () => { if (!currentQuestion) return; setIsSentenceLoading(true); setExampleSentence(null); try { const sentence = await generateExampleSentence(currentQuestion.questionText); setExampleSentence(sentence); } catch (error) { console.error("Failed to generate example sentence:", error); setExampleSentence("Could not generate an example sentence at this time."); } finally { setIsSentenceLoading(false); } };
  const handleGetHint = async () => { if (!currentQuestion || isHintLoading) return; setIsHintLoading(true); setHintUsed(true); try { const hintText = await generateHint(currentQuestion.questionText, currentQuestion.correctAnswer); setHint(hintText); } catch (error) { setHint("Sorry, couldn't get a hint right now."); } finally { setIsHintLoading(false); } };
  const handleFinish = () => handleEndSession(wordResults, Math.round((Date.now() - session.startTime) / 1000));
  const performQuit = () => handleSessionQuit(wordResults, Math.round((Date.now() - session.startTime) / 1000), sessionQueue);
  const handleSaveJournalClick = () => { if (!currentQuestion) return; handleSaveToJournal("Quiz Item", `*Q: ${currentQuestion.questionText}*\n*A: ${currentQuestion.correctAnswer}*`); setIsJournaled(true); };
  const getCardStyle = (): React.CSSProperties => { if (!upgradedRelation?.design) return {}; const design = upgradedRelation.design.front; let background = design.backgroundValue; if (design.backgroundType === 'gradient' && design.backgroundValue.includes(',')) { background = `linear-gradient(${design.gradientAngle}deg, ${design.backgroundValue.split(',').join(', ')})`; } else if (design.backgroundType === 'image') { background = `url("${design.backgroundValue}") center/cover no-repeat, #f0f0f0`; } return { background }; };
  
  const getTypographyStyle = React.useCallback((columnId: string): React.CSSProperties => {
    const fallbackTypo = theme === 'dark' ? DARK_MODE_DEFAULT_TYPOGRAPHY : DEFAULT_TYPOGRAPHY;
    const typo = upgradedRelation?.design?.front.typography[columnId] || fallbackTypo;
    return { color: typo.color, fontSize: typo.fontSize, fontFamily: typo.fontFamily, fontWeight: typo.fontWeight, textAlign: typo.textAlign };
  }, [upgradedRelation, theme]);
  
  const typographyStyle = React.useMemo(() => {
    if (!upgradedRelation || !upgradedRelation.questionColumnIds || upgradedRelation.questionColumnIds.length === 0) {
        const fallbackTypo = theme === 'dark' ? DARK_MODE_DEFAULT_TYPOGRAPHY : DEFAULT_TYPOGRAPHY;
        return { color: fallbackTypo.color, fontSize: fallbackTypo.fontSize, fontFamily: fallbackTypo.fontFamily, fontWeight: fallbackTypo.fontWeight, textAlign: fallbackTypo.textAlign };
    }
    const firstQuestionColId = upgradedRelation.questionColumnIds[0];
    return getTypographyStyle(firstQuestionColId);
  }, [upgradedRelation, getTypographyStyle, theme]);

  if (isFinished) { const correctCount = wordResults.filter(r => r.isCorrect).length; const mastery = Math.round((correctCount / wordResults.length) * 100) || 0; const wordPerformance = initialQuestionOrder.map(rowId => { const results = wordResults.filter(r => r.rowId === rowId); const correct = results.filter(r => r.isCorrect).length; const incorrect = results.length - correct; const questionText = session.questions.find(q=>q.rowId === rowId)?.questionText || "N/A"; return { rowId, questionText, correct, incorrect, score: correct - incorrect * 2 }; }).sort((a,b) => a.score - b.score); const mostDifficult = wordPerformance.slice(0, 3); return ( <div className="fixed inset-0 bg-slate-50 dark:bg-slate-900 flex flex-col items-center justify-start pt-8 sm:pt-16 overflow-y-auto p-4 animate-fadeIn"> <div className="w-full max-w-md text-center"> <h2 className="text-3xl font-bold text-emerald-500 mb-2">Session Complete!</h2> <p className="text-lg text-slate-600 dark:text-slate-300 mb-2">You achieved {mastery}% mastery.</p> <p className="text-sm text-slate-500 dark:text-slate-400 mb-6">{correctCount} correct answers out of {wordResults.length} attempts.</p> </div> <div className="bg-white dark:bg-slate-800 p-4 rounded-lg shadow-inner w-full max-w-md mb-4"> <h3 className="font-bold text-slate-700 dark:text-slate-200 text-center mb-3">Words to Review</h3> <div className="space-y-2"> {mostDifficult.map(p => <div key={p.rowId} className="flex justify-between items-center text-xs p-2 rounded bg-slate-100 dark:bg-slate-700/50"><span className="font-semibold truncate pr-2">{p.questionText}</span><div className="flex gap-2"><span className="text-emerald-500 font-bold">✓ {p.correct}</span><span className="text-red-500 font-bold">✗ {p.incorrect}</span></div></div>)} </div> </div> <div className="bg-white dark:bg-slate-800 p-4 rounded-lg shadow-inner w-full max-w-md mb-6"> <h3 className="font-bold text-slate-700 dark:text-slate-200 text-center mb-3">Full Session Report</h3> <div className="space-y-2 max-h-40 overflow-y-auto pr-2"> {wordPerformance.map(p => ( <div key={p.rowId} className="flex justify-between items-center text-xs p-2 rounded bg-slate-100 dark:bg-slate-700/50"> <span className="font-semibold truncate pr-2">{p.questionText}</span> <div className="flex gap-2 flex-shrink-0"> <span className="text-emerald-500 font-bold">✓ {p.correct}</span> <span className="text-red-500 font-bold">✗ {p.incorrect}</span> </div> </div> ))} </div> </div> <button onClick={handleFinish} className="bg-emerald-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-emerald-700 transition-colors flex-shrink-0">Finish & Save Progress</button> </div> ); }
  if (!currentQuestion) return <div className="fixed inset-0 bg-slate-50 dark:bg-slate-900 flex items-center justify-center"><Icon name="spinner" className="w-8 h-8 animate-spin text-emerald-500"/></div>;

  return ( <> <ConfirmationModal isOpen={isConfirmingQuit} onClose={() => setIsConfirmingQuit(false)} onConfirm={performQuit} title="End Session?" message="Are you sure? Your progress will be saved." confirmText="End Session" /> <div className="fixed inset-0 bg-slate-50 dark:bg-slate-900 flex flex-col items-center justify-center p-4 transition-colors duration-300"> <div className="w-full max-w-lg perspective-1000"> <header className="w-full mb-4"> <div className="flex justify-between items-center text-slate-500 dark:text-slate-400 mb-2"> <button onClick={() => setIsConfirmingQuit(true)} className="p-1 rounded-full hover:text-slate-800 dark:hover:text-white transition-colors"><Icon name="x" className="w-6 h-6" /></button> <div className="flex items-center gap-2 text-xs"><span>Speed Mode</span><button onClick={() => setSpeedMode(!speedMode)} className={`w-10 h-5 flex items-center rounded-full p-1 transition-colors ${speedMode ? 'bg-emerald-500' : 'bg-slate-300 dark:bg-slate-600'}`}><span className={`w-3.5 h-3.5 bg-white rounded-full transition-transform ${speedMode ? 'translate-x-5' : ''}`}></span></button></div> </div> </header> <main onAnimationEnd={handleAnimationEnd} className={`bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl p-6 shadow-lg transform-style-3d ${shake ? 'animate-shake' : ''} ${cardAnimationClass}`} style={getCardStyle()}> <div className="mb-4"><div className="flex justify-between items-center mb-2"><h3 className="text-sm font-semibold uppercase text-slate-500 dark:text-slate-400">Session Progress</h3><button onClick={() => setShowWordsInTracker(!showWordsInTracker)} className="text-slate-400 hover:text-emerald-500 p-1" title={showWordsInTracker ? "Hide" : "Show"}><Icon name="eye" className="w-5 h-5"/></button></div><TopTracker wordStates={wordStates} questionOrder={initialQuestionOrder} sessionQueue={sessionQueue} showWords={showWordsInTracker}/></div> <div className="relative"> <p className="text-slate-500 dark:text-slate-400 mb-2 text-sm uppercase" style={{ color: typographyStyle.color, opacity: 0.7 }}>{currentQuestion.questionSourceColumnNames.join(' + ')}</p> <div className="text-2xl md:text-3xl font-bold text-slate-800 dark:text-white mb-6 min-h-[40px] flex items-center gap-3" style={typographyStyle}> <span>{currentQuestion.questionText}</span> {currentQuestion.type === StudyMode.TrueFalse && <span className="text-base font-normal text-slate-500 dark:text-slate-400">is "{currentQuestion.proposedAnswer}"</span>} <button onClick={handlePlayAudio} disabled={audioState === 'loading'} className="text-slate-400 hover:text-emerald-500 disabled:opacity-50 disabled:cursor-wait"> {audioState === 'loading' ? <Icon name="spinner" className="w-6 h-6 animate-spin"/> : <Icon name="play" className="w-6 h-6"/>} </button> </div> {settings.journalMode === 'manual' && !answered && <button onClick={handleSaveJournalClick} disabled={isJournaled} title="Save to Journal" className="absolute top-0 right-0 p-2 rounded-full text-slate-500 dark:text-slate-400 hover:bg-black/10 disabled:opacity-50"><Icon name="book" className="w-5 h-5"/></button>} </div> <div className="min-h-[140px]"> {!answered ? ( <> {currentQuestion.type === StudyMode.Typing && <TypingQuestionUI onAnswer={handleAnswer} answered={answered}/>} {currentQuestion.type === StudyMode.MultipleChoice && <McqQuestionUI question={currentQuestion} onAnswer={handleAnswer} answered={answered} currentAnswer={currentAnswer}/>} {currentQuestion.type === StudyMode.TrueFalse && <TfQuestionUI onAnswer={handleAnswer} answered={answered}/>} <div className="mt-2 text-center"> <button onClick={handleGetHint} disabled={isHintLoading || !!hint} className="text-sm font-semibold text-cyan-600 dark:text-cyan-400 hover:underline disabled:opacity-50 disabled:cursor-not-allowed"> {isHintLoading ? 'Getting hint...' : (hint ? 'Hint given' : 'Need a hint?')} </button> {hint && <p className="text-sm text-slate-500 dark:text-slate-400 mt-1 italic">"{hint}"</p>} </div> </> ) : ( <div className="animate-fadeIn"> <div className={`flex items-center justify-between p-3 rounded-lg ${feedback === 'correct' ? 'bg-emerald-500/10 text-emerald-700 dark:text-emerald-300' : 'bg-red-500/10 text-red-700 dark:text-red-300'}`}> <div className="flex items-center"><Icon name={feedback === 'correct' ? 'check' : 'x'} className="w-5 h-5 mr-3"/><div><p className="font-bold text-sm">{feedback === 'correct' ? 'Correct!' : 'Incorrect'}</p>{feedback === 'incorrect' && <p className="text-sm">Answer: <span className="font-bold">{currentQuestion.correctAnswer}</span></p>}</div></div> </div> <div className="mt-3"> {!exampleSentence && !isSentenceLoading && ( <button onClick={handleGenerateExample} className="w-full text-left flex items-center gap-2 text-sm font-semibold text-cyan-600 dark:text-cyan-400 hover:bg-cyan-500/10 p-2 rounded-md transition-colors"> <Icon name="sparkles" className="w-4 h-4" /> Show Example Sentence </button> )} {isSentenceLoading && ( <div className="flex items-center justify-center p-2 text-sm text-slate-500"> <Icon name="spinner" className="w-4 h-4 animate-spin mr-2"/> Generating... </div> )} {exampleSentence && ( <div className="p-3 bg-slate-100 dark:bg-slate-700/50 rounded-lg"> <p className="text-sm text-slate-700 dark:text-slate-300 italic">"{exampleSentence}"</p> </div> )} </div> <FullExplanationPanel question={currentQuestion} onOpenGalleryView={handleOpenGalleryView} /> {!speedMode && <button type="button" onClick={handleNextQuestion} className="w-full mt-2 bg-slate-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-slate-700 transition-colors">Next</button>} </div> )} </div> </main> </div> </div> </> );
};

export default StudySessionScreen;